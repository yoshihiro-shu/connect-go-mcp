# protoc-gen-connect-go-mcp

gRPCサービス定義からMCP（Model Context Protocol）サーバーコードを生成するProtocol Buffersコンパイラプラグインです。

## 概要

`protoc-gen-connect-go-mcp`は、既存のgRPCサービス定義からMCPサーバー実装を自動生成するprotocプラグインです。MCP対応アプリケーションに統合可能な、即座に使用できるMCPツールを作成します。

## 特徴

- **自動MCPサーバー生成**: gRPCサービスをMCPサーバー実装に変換
- **公式MCP SDK**: 最大限の互換性のために公式MCP Go SDKを使用
- **柔軟なパッケージ構成**: より良いコード整理のためのカスタムパッケージサフィックスをサポート
- **複数行コメント対応**: より良いツール説明のためにprotoファイルコメントの書式を保持
- **Connect-Go互換**: 完全なgRPCサポートのために`protoc-gen-connect-go`と連携動作

## インストール

### 前提条件

- Go 1.23 以降
- Protocol Buffersコンパイラ（`protoc`）
- `buf` CLIツール（推奨）

### インストール

```bash
go install github.com/yoshihiro-shu/connect-go-mcp/cmd/protoc-gen-connect-go-mcp@latest
```

## 使用方法

### bufを使用する場合

`buf.gen.yaml`を作成または更新：

```yaml
version: v2
plugins:
  - local: protoc-gen-go
    out: gen
    opt: paths=source_relative
  - local: protoc-gen-connect-go
    out: gen
    opt: paths=source_relative
  - local: protoc-gen-connect-go-mcp
    out: gen
    opt: paths=source_relative
```

その後実行：

```bash
buf generate
```

### protocを使用する場合

```bash
protoc \
  --go_out=. --go_opt=paths=source_relative \
  --connect-go_out=. --connect-go_opt=paths=source_relative \
  --connect-go-mcp_out=. --connect-go-mcp_opt=paths=source_relative \
  your_service.proto
```

## 設定オプション

### package_suffix

生成ファイルのパッケージ命名とディレクトリ構造を制御します。

#### デフォルト動作（package_suffixなし）

```yaml
plugins:
  - local: protoc-gen-connect-go-mcp
    out: gen
    opt: paths=source_relative
```

**出力**: `gen/greetv1mcp/greet.mcpserver.go` with `package greetv1mcp`

#### カスタムサフィックス

```yaml
plugins:
  - local: protoc-gen-connect-go-mcp
    out: gen
    opt: paths=source_relative,package_suffix=tools
```

**出力**: `gen/greetv1tools/greet.mcpserver.go` with `package greetv1tools`

#### 空サフィックス（フラット構造）

```yaml
plugins:
  - local: protoc-gen-connect-go-mcp
    out: gen
    opt: paths=source_relative,package_suffix=
```

**出力**: `gen/greet.mcpserver.go` with `package greetv1`

## 例

### 入力Protoファイル

```protobuf
syntax = "proto3";

package greet.v1;

option go_package = "github.com/example/gen/greet/v1;greetv1";

// MCP実演用のGreetingサービス
service GreetService {
  // Greet RPC
  // このメソッドはユーザーに挨拶します
  // パラメータ name: 挨拶する人の名前（必須）
  // 戻り値: パーソナライズされた挨拶メッセージ
  rpc Greet(GreetRequest) returns (GreetResponse);

  // Ping RPC
  // 接続性をテストするためのシンプルなping-pongメソッド
  rpc Ping(PingRequest) returns (PingResponse);
}

message GreetRequest {
  string name = 1; // 挨拶する人の名前
}

message GreetResponse {
  string message = 1; // 挨拶メッセージ
}

message PingRequest {
  string message = 1; // Pingメッセージ
}

message PingResponse {
  string message = 1; // Pong応答
}
```

### 生成されるMCPサーバー

```go
// Code generated by connect-go-mcp DO NOT EDIT.
package greetv1mcp

import (
    "context"

    "github.com/modelcontextprotocol/go-sdk/mcp"
    connectgomcp "github.com/yoshihiro-shu/connect-go-mcp"
)

// NewGreetServiceMCPServer はGreetService用の設定済みMCPサーバーを作成します
func NewGreetServiceMCPServer(baseURL string, opts ...connectgomcp.ClientOption) *mcp.Server {
    server := mcp.NewServer(&mcp.Implementation{
        Name:    "GreetService",
        Version: "1.0.0",
    }, nil)

    toolHandler := connectgomcp.NewToolHandler(baseURL, opts...)

    mcp.AddTool(
        server,
        &mcp.Tool{
            Name:        "Greet RPC",
            Description: "このメソッドはユーザーに挨拶します\nパラメータ name: 挨拶する人の名前（必須）\n戻り値: パーソナライズされた挨拶メッセージ",
        },
        func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
            result, err := toolHandler.Handle(ctx, req, "Greet")
            if err != nil {
                return nil, nil, err
            }
            return result, nil, nil
        },
    )

    mcp.AddTool(
        server,
        &mcp.Tool{
            Name:        "Ping RPC",
            Description: "接続性をテストするためのシンプルなping-pongメソッド",
        },
        func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
            result, err := toolHandler.Handle(ctx, req, "Ping")
            if err != nil {
                return nil, nil, err
            }
            return result, nil, nil
        },
    )

    return server
}
```

### 生成されたサーバーの使用

```go
package main

import (
    "context"
    "log"

    "github.com/modelcontextprotocol/go-sdk/mcp"
    greetv1mcp "github.com/example/gen/greet/v1/greetv1mcp"
)

func main() {
    // MCPサーバーインスタンスを作成
    mcpServer := greetv1mcp.NewGreetServiceMCPServer("http://localhost:8080")

    // stdio transportでMCPサーバーを開始
    ctx := context.Background()
    if err := mcpServer.Run(ctx, &mcp.StdioTransport{}); err != nil {
        log.Fatal(err)
    }
}
```

## 生成されるコード構造

プラグインは以下を生成します：

1. **MCPサーバーコンストラクタ**: `New{ServiceName}MCPServer()` 関数
2. **ツール定義**: 各RPCメソッドがMCPツールになります
3. **パラメータマッピング**: Protoメッセージフィールドがツールパラメータになります
4. **コメント**: ツール説明として保持されます
5. **型安全性**: すべての操作で完全なGo型安全性

## MCPエコシステムとの統合

生成されたサーバーは以下と互換性があります：

- **Claude Desktop**: AI支援のためのMCPツールとして追加
- **MCPクライアント**: MCPプロトコルを実装する任意のクライアント
- **カスタムアプリケーション**: アプリにMCP機能を統合

## 開発

### テストの実行

```bash
cd cmd/protoc-gen-connect-go-mcp
go test -v
```

### テスト要件

- Protocol Buffersコンパイラ（`protoc`）がインストールされている必要があります
- `protoc`が利用できない場合、テストは自動的にスキップされます

## コントリビューション

1. リポジトリをフォーク
2. フィーチャーブランチを作成 (`git checkout -b feature/amazing-feature`)
3. 変更をコミット (`git commit -m 'Add some amazing feature'`)
4. ブランチにプッシュ (`git push origin feature/amazing-feature`)
5. プルリクエストを開く

## ライセンス

このプロジェクトはMITライセンスの下でライセンスされています - 詳細は[LICENSE](../../LICENSE)ファイルを参照してください。

## 関連プロジェクト

- [go-sdk](https://github.com/modelcontextprotocol/go-sdk) - 公式MCP Go SDK
- [connect-go](https://github.com/connectrpc/connect-go) - シンプルで信頼性が高く相互運用可能なRPC
- [buf](https://github.com/bufbuild/buf) - Protocol Bufferツールキット
- [Model Context Protocol](https://modelcontextprotocol.io/) - MCP公式ドキュメント