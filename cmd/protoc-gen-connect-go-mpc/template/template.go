package template

import (
	"fmt"
	"strings"

	"github.com/yoshihiro-shu/connect-go-mpc/cmd/protoc-gen-connect-go-mpc/parser"
	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateCode はMCPサーバーコードを生成します
func GenerateCode(g *protogen.GeneratedFile, pkgName string, services []parser.Service) error {
	// インポート
	g.P("// Code generated by connect-go-mpc. DO NOT EDIT.")
	g.P("package ", pkgName, "_connect_mpcserver")
	g.P()

	// インポート宣言
	generateImports(g, services)
	g.P()

	// 各サービスに対するコード生成
	for _, service := range services {
		// NewMCPServerWithTools 関数
		generateServerWithTools(g, service)
		g.P()
	}

	return nil
}

// generateImports はインポート宣言を生成します
func generateImports(g *protogen.GeneratedFile, services []parser.Service) {
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P()
	g.P(`	"connectrpc.com/connect"`)
	g.P(`	"github.com/mark3labs/mcp-go/mcp"`)
	g.P(`	"github.com/mark3labs/mcp-go/server"`)
	g.P(`	"github.com/yoshihiro-shu/connect-go-mpc/connect_mpcserver"`)
	g.P(")")
}

// generateServerWithTools はMCPサーバー初期化関数を生成します
func generateServerWithTools(g *protogen.GeneratedFile, service parser.Service) {
	g.P("// NewMCPServerWithTools は設定済みの ", service.Name, " MCP サーバーを生成して返します")
	g.P("func New", service.Name, "MCPServer(baseURL string, opts ...connect_mpcserver.ClientOption) *mcp.Server {")
	g.P("  server := server.NewMCPServer(\"", service.Name, "\", \"1.0.0\")")
	g.P()
	g.P("  toolHandler := connect_mpcserver.NewToolHandler(baseURL, opts...)")

	// 各メソッドに対するツール登録
	for _, method := range service.Methods {
		toolName := method.Comment
		if toolName == "" {
			toolName = method.Name
		}

		g.P("  server.AddTool(")
		g.P(`    mcp.NewTool("`, toolName, `",`)

		// 説明
		if method.RequestComment != "" {
			g.P(`      mcp.WithDescription("`, escapeString(method.RequestComment), `"),`)
		}

		// パラメータ定義
		for _, field := range method.RequestFields {
			paramType := getParamType(field.Type)

			g.P(`      mcp.With`, paramType, `("`, field.Name, `",`)
			if field.IsRequired {
				g.P(`        mcp.Required(),`)
			}
			if field.Description != "" {
				g.P(`        mcp.Description("`, escapeString(field.Description), `"),`)
			}
			g.P(`      ),`)
		}

		g.P("    ),")
		g.P("    func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {")
		g.P("      return toolHandler.Handle(ctx, req, \"", method.Name, "\")")
		g.P("    },")
		g.P("  )")
		g.P()
	}

	g.P("  return server")
	g.P("}")
}

// generateHandler はハンドラー関数を生成します
func generateHandler(g *protogen.GeneratedFile, service parser.Service, method parser.Method) {
	g.P("func handle", method.Name, "(ctx context.Context, req mcp.CallToolRequest, client ", method.RequestConnectType, ") (*mcp.CallToolResult, error) {")

	// リクエストパラメータの取得
	for _, field := range method.RequestFields {
		genParamExtraction(g, field)
	}
	g.P()

	// リクエスト構築
	g.P("  // gRPCリクエスト生成")
	g.P("  grpcReq := &", method.RequestType, "{")
	for _, field := range method.RequestFields {
		fieldName := ucFirst(field.Name)
		g.P("    ", fieldName, ": ", field.Name, ",")
	}
	g.P("  }")
	g.P()

	// gRPCリクエスト送信
	g.P("  // リクエスト送信")
	g.P("  resp, err := client.", method.Name, "(ctx, connect.NewRequest(grpcReq))")
	g.P("  if err != nil {")
	g.P(`    return nil, fmt.Errorf("failed to call `, method.Name, `: %w", err)`)
	g.P("  }")
	g.P()

	// レスポンス変換
	g.P("  // レスポンス変換")
	g.P("  return mcp.NewToolResultJSON(map[string]interface{}{")
	g.P(`    "response": resp.Msg,`)
	g.P("  }), nil")
	g.P("}")
}

// genParamExtraction はパラメータ抽出コードを生成します
func genParamExtraction(g *protogen.GeneratedFile, field parser.Field) {
	varName := field.Name
	extractCode := ""

	switch field.Type {
	case "string":
		extractCode = fmt.Sprintf(`%s, _ := req.Params.Arguments["%s"].(string)`, varName, field.Name)
	case "bool":
		extractCode = fmt.Sprintf(`%s, _ := req.Params.Arguments["%s"].(bool)`, varName, field.Name)
	case "int32", "int64":
		extractCode = fmt.Sprintf(`%sFloat, _ := req.Params.Arguments["%s"].(float64)`, varName, field.Name)
		extractCode += fmt.Sprintf("\n  %s := %s(%sFloat)", varName, field.Type, varName)
	case "float32", "float64":
		extractCode = fmt.Sprintf(`%s, _ := req.Params.Arguments["%s"].(float64)`, varName, field.Name)
	default:
		extractCode = fmt.Sprintf(`%s, _ := req.Params.Arguments["%s"]`, varName, field.Name)
	}

	g.P("  ", extractCode)
}

// getParamType はMCPパラメータ型を取得します
func getParamType(goType string) string {
	switch goType {
	case "string":
		return "String"
	case "bool":
		return "Bool"
	case "int32", "int64", "float32", "float64":
		return "Number"
	default:
		return "Object"
	}
}

// escapeString は文字列をエスケープします
func escapeString(s string) string {
	return strings.ReplaceAll(s, `"`, `\"`)
}

// ucFirst は最初の文字を大文字にします
func ucFirst(s string) string {
	if s == "" {
		return ""
	}
	r := []rune(s)
	r[0] = toUpper(r[0])
	return string(r)
}

// toLower は文字を小文字に変換します
func toLower(r rune) rune {
	if r >= 'A' && r <= 'Z' {
		return r - 'A' + 'a'
	}
	return r
}

// toUpper は文字を大文字に変換します
func toUpper(r rune) rune {
	if r >= 'a' && r <= 'z' {
		return r - 'a' + 'A'
	}
	return r
}
