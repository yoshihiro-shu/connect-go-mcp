package main

import (
	"bytes"
	"io"
	"os"
	"os/exec"
	"testing"

	"github.com/stretchr/testify/assert"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func TestVersion(t *testing.T) {
	t.Parallel()
	stdout, stderr, exitCode := testRunCommand(t, nil, "--version")
	t.Logf("stdout: %s", stdout.String())
	t.Logf("stderr: %s", stderr.String())
	t.Logf("exitCode: %d", exitCode)
	assert.Equal(t, stdout.String(), version+"\n")
	assert.Equal(t, stderr.String(), "")
	assert.Equal(t, exitCode, 0)
}

func TestGenerate(t *testing.T) {
	t.Parallel()

	// 実際のbuf generateと同じ条件でテストするため
	// protocコマンドを直接使用してファイル記述子を取得
	stdout, stderr, exitCode := testRunProtocCommand(t,
		"--descriptor_set_out=/dev/stdout",
		"--include_source_info",
		"--include_imports",
		"--proto_path=testdata/greet",
		"testdata/greet/greet.proto",
	)

	assert.Equal(t, exitCode, 0, "protoc command failed: %s", stderr.String())

	var fileDescriptorSet descriptorpb.FileDescriptorSet
	err := proto.Unmarshal(stdout.Bytes(), &fileDescriptorSet)
	assert.Nil(t, err)

	// greet.protoファイルを見つける
	var greetFileDesc *descriptorpb.FileDescriptorProto
	for _, file := range fileDescriptorSet.File {
		if file.GetName() == "greet.proto" {
			greetFileDesc = file
			break
		}
	}
	assert.NotNil(t, greetFileDesc, "greet.proto not found in descriptor set")

	compilerVersion := &pluginpb.Version{
		Major:  ptr(int32(0)),
		Minor:  ptr(int32(0)),
		Patch:  ptr(int32(1)),
		Suffix: ptr("test"),
	}

	// buf.gen.yamlのオプションと同じパラメータを設定
	req := &pluginpb.CodeGeneratorRequest{
		FileToGenerate:        []string{greetFileDesc.GetName()},
		Parameter:             ptr("paths=source_relative"),
		ProtoFile:             fileDescriptorSet.File,
		SourceFileDescriptors: fileDescriptorSet.File,
		CompilerVersion:       compilerVersion,
	}
	rsp := testGenerate(t, req)
	assert.Nil(t, rsp.Error)

	assert.Equal(t, len(rsp.File), 1)

	if len(rsp.File) == 0 {
		t.Fatal("No files generated")
	}

	file := rsp.File[0]

	// 期待されるファイル名を確認（mcpディレクトリ内に配置される）
	expectedFileName := "greetv1mcp/greet.mcpserver.go"
	assert.Equal(t, expectedFileName, file.GetName())

	// 生成されたコンテンツを検証
	content := file.GetContent()
	assert.NotZero(t, content)

	// Verify that the same content as actual buf generate is generated
	assert.Contains(t, content, `// Code generated by connect-go-mcp DO NOT EDIT.`)
	assert.Contains(t, content, `package greetv1`)
	assert.Contains(t, content, `func NewGreetServiceMCPServer`)
	assert.Contains(t, content, `mcp.NewTool("Greet RPC",`)
	assert.Contains(t, content, `mcp.WithDescription("Greeting request"),`)
	assert.Contains(t, content, `mcp.NewTool("Ping RPC",`)
	assert.Contains(t, content, `mcp.WithDescription("Ping request"),`)
	assert.Contains(t, content, `mcp.WithString("name")`)
	assert.Contains(t, content, `mcp.WithString("message")`)
}

func TestGenerateMatchesBufOutput(t *testing.T) {
	t.Parallel()

	// 実際のbuf generateで生成されたファイルを読み込み
	expectedContent, err := os.ReadFile("testdata/greet/gen/greetv1mcp/greet.mcpserver.go")
	assert.Nil(t, err, "Failed to read expected file")

	// 実際のbuf generateと同じ条件でテストするため
	// protocコマンドを直接使用してファイル記述子を取得
	stdout, stderr, exitCode := testRunProtocCommand(t,
		"--descriptor_set_out=/dev/stdout",
		"--include_source_info",
		"--include_imports",
		"--proto_path=testdata/greet",
		"testdata/greet/greet.proto",
	)

	assert.Equal(t, exitCode, 0, "protoc command failed: %s", stderr.String())

	var fileDescriptorSet descriptorpb.FileDescriptorSet
	err = proto.Unmarshal(stdout.Bytes(), &fileDescriptorSet)
	assert.Nil(t, err)

	// greet.protoファイルを見つける
	var greetFileDesc *descriptorpb.FileDescriptorProto
	for _, file := range fileDescriptorSet.File {
		if file.GetName() == "greet.proto" {
			greetFileDesc = file
			break
		}
	}
	assert.NotNil(t, greetFileDesc, "greet.proto not found in descriptor set")

	compilerVersion := &pluginpb.Version{
		Major:  ptr(int32(0)),
		Minor:  ptr(int32(0)),
		Patch:  ptr(int32(1)),
		Suffix: ptr("test"),
	}

	// buf.gen.yamlと同じ設定を使用
	req := &pluginpb.CodeGeneratorRequest{
		FileToGenerate:        []string{greetFileDesc.GetName()},
		Parameter:             ptr("paths=source_relative"),
		ProtoFile:             fileDescriptorSet.File,
		SourceFileDescriptors: fileDescriptorSet.File,
		CompilerVersion:       compilerVersion,
	}

	rsp := testGenerate(t, req)
	assert.Nil(t, rsp.Error)
	assert.Equal(t, len(rsp.File), 1)

	if len(rsp.File) == 0 {
		t.Fatal("No files generated")
	}

	file := rsp.File[0]
	assert.Equal(t, "greetv1mcp/greet.mcpserver.go", file.GetName())

	// 生成された内容と期待される内容が完全に一致することを確認
	generatedContent := file.GetContent()
	assert.Equal(t, string(expectedContent), generatedContent,
		"Generated content should match buf generate output")
}

func TestGenerateWithPackageSuffix(t *testing.T) {
	t.Parallel()

	// 実際のbuf generateと同じ条件でテストするため
	// protocコマンドを直接使用してファイル記述子を取得
	stdout, stderr, exitCode := testRunProtocCommand(t,
		"--descriptor_set_out=/dev/stdout",
		"--include_source_info",
		"--include_imports",
		"--proto_path=testdata/greet",
		"testdata/greet/greet.proto",
	)

	assert.Equal(t, exitCode, 0, "protoc command failed: %s", stderr.String())

	var fileDescriptorSet descriptorpb.FileDescriptorSet
	err := proto.Unmarshal(stdout.Bytes(), &fileDescriptorSet)
	assert.Nil(t, err)

	// greet.protoファイルを見つける
	var greetFileDesc *descriptorpb.FileDescriptorProto
	for _, file := range fileDescriptorSet.File {
		if file.GetName() == "greet.proto" {
			greetFileDesc = file
			break
		}
	}
	assert.NotNil(t, greetFileDesc, "greet.proto not found in descriptor set")

	compilerVersion := &pluginpb.Version{
		Major:  ptr(int32(0)),
		Minor:  ptr(int32(0)),
		Patch:  ptr(int32(1)),
		Suffix: ptr("test"),
	}

	// package_suffixパラメータを設定
	req := &pluginpb.CodeGeneratorRequest{
		FileToGenerate:        []string{greetFileDesc.GetName()},
		Parameter:             ptr("paths=source_relative,package_suffix=mcp"),
		ProtoFile:             fileDescriptorSet.File,
		SourceFileDescriptors: fileDescriptorSet.File,
		CompilerVersion:       compilerVersion,
	}
	rsp := testGenerate(t, req)
	assert.Nil(t, rsp.Error)

	assert.Equal(t, len(rsp.File), 1)

	if len(rsp.File) == 0 {
		t.Fatal("No files generated")
	}

	file := rsp.File[0]

	// 期待されるファイル名を確認（mcpディレクトリ内に配置される）
	expectedFileName := "greetv1mcp/greet.mcpserver.go"
	assert.Equal(t, expectedFileName, file.GetName())

	// 生成されたコンテンツを検証
	content := file.GetContent()
	assert.NotZero(t, content)

	// package_suffixが適用されていることを確認
	assert.Contains(t, content, `package greetv1mcp`)
	assert.Contains(t, content, `func NewGreetServiceMCPServer`)
}

func TestGenerateWithEmptyPackageSuffix(t *testing.T) {
	t.Parallel()

	// 実際のbuf generateと同じ条件でテストするため
	// protocコマンドを直接使用してファイル記述子を取得
	stdout, stderr, exitCode := testRunProtocCommand(t,
		"--descriptor_set_out=/dev/stdout",
		"--include_source_info",
		"--include_imports",
		"--proto_path=testdata/greet",
		"testdata/greet/greet.proto",
	)

	assert.Equal(t, exitCode, 0, "protoc command failed: %s", stderr.String())

	var fileDescriptorSet descriptorpb.FileDescriptorSet
	err := proto.Unmarshal(stdout.Bytes(), &fileDescriptorSet)
	assert.Nil(t, err)

	// greet.protoファイルを見つける
	var greetFileDesc *descriptorpb.FileDescriptorProto
	for _, file := range fileDescriptorSet.File {
		if file.GetName() == "greet.proto" {
			greetFileDesc = file
			break
		}
	}
	assert.NotNil(t, greetFileDesc, "greet.proto not found in descriptor set")

	compilerVersion := &pluginpb.Version{
		Major:  ptr(int32(0)),
		Minor:  ptr(int32(0)),
		Patch:  ptr(int32(1)),
		Suffix: ptr("test"),
	}

	// package_suffix=（空文字列）パラメータを設定
	req := &pluginpb.CodeGeneratorRequest{
		FileToGenerate:        []string{greetFileDesc.GetName()},
		Parameter:             ptr("paths=source_relative,package_suffix="),
		ProtoFile:             fileDescriptorSet.File,
		SourceFileDescriptors: fileDescriptorSet.File,
		CompilerVersion:       compilerVersion,
	}
	rsp := testGenerate(t, req)
	assert.Nil(t, rsp.Error)

	assert.Equal(t, len(rsp.File), 1)

	if len(rsp.File) == 0 {
		t.Fatal("No files generated")
	}

	file := rsp.File[0]

	// 期待されるファイル名を確認（現在のディレクトリに直接配置）
	expectedFileName := "greet.mcpserver.go"
	assert.Equal(t, expectedFileName, file.GetName())

	// 生成されたコンテンツを検証
	content := file.GetContent()
	assert.NotZero(t, content)

	// 元のパッケージ名が使われていることを確認
	assert.Contains(t, content, `package greetv1`)
	assert.Contains(t, content, `func NewGreetServiceMCPServer`)
}

// testRunCommand executes the main.go with the given arguments and optional stdin input.
// It returns the captured stdout, stderr buffers and the exit code. This helper is used
// to test the protoc plugin behavior by running it as a Go program.
func testRunCommand(t *testing.T, stdin io.Reader, args ...string) (stdout, stderr *bytes.Buffer, exitCode int) {
	t.Helper()

	stdout = &bytes.Buffer{}
	stderr = &bytes.Buffer{}
	args = append([]string{"run", "main.go"}, args...)

	cmd := exec.Command("go", args...)
	cmd.Env = os.Environ()
	cmd.Stdin = stdin
	cmd.Stdout = stdout
	cmd.Stderr = stderr
	err := cmd.Run()
	if err != nil {
		t.Logf("Command failed: %v", err)
	}
	exitCode = cmd.ProcessState.ExitCode()
	return stdout, stderr, exitCode
}

// testRunProtocCommand executes the protoc command with the given arguments and returns
// the stdout, stderr buffers and exit code. This helper function is used to generate
// file descriptor sets with source info from actual .proto files, ensuring that
// comments and other source-level information are preserved for testing.
func testRunProtocCommand(t *testing.T, args ...string) (stdout, stderr *bytes.Buffer, exitCode int) {
	t.Helper()

	stdout = &bytes.Buffer{}
	stderr = &bytes.Buffer{}

	cmd := exec.Command("protoc", args...)
	cmd.Env = os.Environ()
	cmd.Stdout = stdout
	cmd.Stderr = stderr
	err := cmd.Run()
	if err != nil {
		t.Logf("protoc command failed: %v", err)
	}
	exitCode = cmd.ProcessState.ExitCode()
	return stdout, stderr, exitCode
}

// testGenerate runs the protoc plugin with the given CodeGeneratorRequest and returns
// the CodeGeneratorResponse. This helper function marshals the request, passes it to
// the plugin via stdin, and unmarshals the response from stdout.
func testGenerate(t *testing.T, req *pluginpb.CodeGeneratorRequest) *pluginpb.CodeGeneratorResponse {
	t.Helper()

	inputBytes, err := proto.Marshal(req)
	assert.Nil(t, err)

	stdout, stderr, exitCode := testRunCommand(t, bytes.NewReader(inputBytes))

	if exitCode != 0 {
		t.Logf("Command failed with exit code %d", exitCode)
		t.Logf("stderr: %s", stderr.String())
		t.Logf("stdout: %s", stdout.String())
	}

	if len(stdout.Bytes()) == 0 {
		t.Fatal("No output from command")
	}

	var output pluginpb.CodeGeneratorResponse
	if err := proto.Unmarshal(stdout.Bytes(), &output); err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}
	return &output
}

// ptr is a generic helper function that returns a pointer to the given value.
// This is useful for creating pointers to literal values in test data.
func ptr[T any](v T) *T {
	return &v
}
