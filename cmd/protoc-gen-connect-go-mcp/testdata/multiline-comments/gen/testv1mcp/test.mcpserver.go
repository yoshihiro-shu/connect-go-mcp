// Code generated by connect-go-mcp DO NOT EDIT.
package testv1mcp

import (
	"context"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	connectgomcp "github.com/yoshihiro-shu/connect-go-mcp"
)

// NewMCPServerWithTools creates and returns a configured TestService MCP server
func NewTestServiceMCPServer(baseURL string, opts ...connectgomcp.ClientOption) *mcp.Server {
	server := mcp.NewServer(&mcp.Implementation{
		Name:    "TestService provides test functionality\nThis service demonstrates handling of multiline comments in proto files",
		Version: "1.0.0",
	}, nil)

	toolHandler := connectgomcp.NewToolHandler(baseURL, opts...)
	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "CreateUser - Creates a new user account in the system.\nNOTE: This method requires valid email verification before account activation.",
			Description: "CreateUser - Creates a new user account.\n\nPrerequisites:\n- Valid email address\n- User must not already exist\n- Terms of service must be accepted",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "CreateUser")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "GetUser - Retrieves user information by user ID.\n\nPrerequisites:\n- Valid user ID must be provided\n- User must exist in the system",
			Description: "GetUser - Retrieves user information.\n\nReturns:\n- User profile data if found\n- Error if user does not exist",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "GetUser")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "UpdateUser - Updates an existing user's information.\n\nThis operation allows updating user profile data.\nOnly the fields provided in the request will be updated.",
			Description: "UpdateUser - Updates user information.\n\nOnly non-empty fields will be updated.\nTo clear a field, use the appropriate \"clear_*\" flag.",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "UpdateUser")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "DeleteUser - Deletes a user account from the system.\n\nWARNING: This operation is irreversible!\nAll user data will be permanently deleted.",
			Description: "DeleteUser - Permanently deletes a user.\n\nWARNING: This cannot be undone!",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "DeleteUser")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "SyncData\nSynchronizes data between the client and server.\nThis operation may take several minutes depending on the data size.",
			Description: "SyncDataRequest\nRequest message for synchronizing data.\nThe sync operation will process all pending changes since the last sync.",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "SyncData")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	mcp.AddTool(
		server,
		&mcp.Tool{
			Name:        "ProcessPayment - Processes a payment transaction.\n\nThis is a test RPC for demonstrating multiline comments.\nIt includes special characters like \"quotes\" and \\backslashes\\.\nMultiple lines should be properly escaped in the generated code.",
			Description: "ProcessPaymentRequest\nRequest for processing a payment.",
		},
		func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {
			result, err := toolHandler.Handle(ctx, req, "ProcessPayment")
			if err != nil {
				return nil, nil, err
			}
			return result, nil, nil
		},
	)

	return server
}
