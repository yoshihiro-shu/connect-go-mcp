package template

import (
	"strings"

	"github.com/yoshihiro-shu/connect-go-mcp/cmd/protoc-gen-connect-go-mcp/parser"
	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateCode generates MCP server code
func GenerateCode(g *protogen.GeneratedFile, pkgName string, services []parser.Service) error {
	// Import
	g.P("// Code generated by connect-go-mcp DO NOT EDIT.")
	g.P("package ", pkgName)
	g.P()

	// Import declarations
	generateImports(g, services)
	g.P()

	// Code generation for each service
	for i, service := range services {
		// NewMCPServerWithTools function
		generateServerWithTools(g, service)
		if i < len(services)-1 {
			g.P()
		}
	}

	return nil
}

// generateImports generates import declarations
func generateImports(g *protogen.GeneratedFile, services []parser.Service) {
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/google/jsonschema-go/jsonschema"`)
	g.P(`	"github.com/modelcontextprotocol/go-sdk/mcp"`)
	g.P(`	connectgomcp "github.com/yoshihiro-shu/connect-go-mcp"`)
	g.P(")")
}

// generateServerWithTools generates MCP server initialization function
func generateServerWithTools(g *protogen.GeneratedFile, service parser.Service) {
	// Use service comment as MCP server name if available, otherwise use service name
	serverName := service.Comment
	if serverName == "" {
		serverName = service.Name
	}

	g.P("// NewMCPServerWithTools creates and returns a configured ", service.Name, " MCP server")
	g.P("func New", service.Name, "MCPServer(baseURL string, opts ...connectgomcp.ClientOption) *mcp.Server {")
	g.P("  server := mcp.NewServer(&mcp.Implementation{")
	g.P("    Name: \"", escapeString(serverName), "\",")
	g.P("    Version: \"1.0.0\",")
	g.P("  }, nil)")
	g.P()
	g.P("  toolHandler := connectgomcp.NewToolHandler(baseURL, opts...)")

	// Tool registration for each method
	for i, method := range service.Methods {
		toolName := method.Comment
		if toolName == "" {
			toolName = method.Name
		}

		description := method.RequestComment
		if description == "" {
			description = "Call " + method.Name + " method"
		}

		g.P("  mcp.AddTool(")
		g.P("    server,")
		g.P("    &mcp.Tool{")
		g.P("      Name: \"", escapeString(toolName), "\",")
		g.P("      Description: \"", escapeString(description), "\",")
		generateInputSchema(g, method.RequestFields)
		g.P("    },")
		g.P("    func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {")
		g.P("      result, err := toolHandler.Handle(ctx, req, \"", method.Name, "\")")
		g.P("      if err != nil {")
		g.P("        return nil, nil, err")
		g.P("      }")
		g.P("      return result, nil, nil")
		g.P("    },")
		g.P("  )")

		// Add blank line between methods, but not after the last one
		if i < len(service.Methods)-1 {
			g.P()
		}
	}

	g.P()
	g.P("  return server")
	g.P("}")
}

// generateInputSchema generates InputSchema for a tool
func generateInputSchema(g *protogen.GeneratedFile, fields []parser.Field) {
	g.P("      InputSchema: &jsonschema.Schema{")
	g.P("        Type: \"object\",")

	if len(fields) > 0 {
		g.P("        Properties: map[string]*jsonschema.Schema{")
		for _, field := range fields {
			jsonType := getJSONSchemaType(field.Type)
			description := field.Comment
			if description == "" {
				description = field.Name
			}
			g.P("          \"", field.Name, "\": {")
			g.P("            Type: \"", jsonType, "\",")
			g.P("            Description: \"", escapeString(description), "\",")
			g.P("          },")
		}
		g.P("        },")

		// Generate required fields
		var requiredFields []string
		for _, field := range fields {
			if field.IsRequired {
				requiredFields = append(requiredFields, field.Name)
			}
		}
		if len(requiredFields) > 0 {
			g.P("        Required: []string{")
			for _, name := range requiredFields {
				g.P("          \"", name, "\",")
			}
			g.P("        },")
		}
	}

	g.P("      },")
}

// getJSONSchemaType converts Go type to JSON Schema type
func getJSONSchemaType(goType string) string {
	switch goType {
	case "string":
		return "string"
	case "bool":
		return "boolean"
	case "int32", "int64":
		return "integer"
	case "float32", "float64":
		return "number"
	default:
		return "object"
	}
}

// escapeString escapes strings for Go string literals
func escapeString(s string) string {
	// Order matters: backslash must be escaped first
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", `\n`)
	s = strings.ReplaceAll(s, "\r", `\r`)
	s = strings.ReplaceAll(s, "\t", `\t`)
	return s
}
