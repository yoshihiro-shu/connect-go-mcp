package template

import (
	"strings"

	"github.com/yoshihiro-shu/connect-go-mcp/cmd/protoc-gen-connect-go-mcp/parser"
	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateCode generates MCP server code
func GenerateCode(g *protogen.GeneratedFile, pkgName string, services []parser.Service) error {
	// Import
	g.P("// Code generated by connect-go-mcp DO NOT EDIT.")
	g.P("package ", pkgName)
	g.P()

	// Import declarations
	generateImports(g, services)
	g.P()

	// Code generation for each service
	for i, service := range services {
		// NewMCPServerWithTools function
		generateServerWithTools(g, service)
		if i < len(services)-1 {
			g.P()
		}
	}

	return nil
}

// generateImports generates import declarations
func generateImports(g *protogen.GeneratedFile, services []parser.Service) {
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/modelcontextprotocol/go-sdk/mcp"`)
	g.P(`	connectgomcp "github.com/yoshihiro-shu/connect-go-mcp"`)
	g.P(")")
}

// generateServerWithTools generates MCP server initialization function
func generateServerWithTools(g *protogen.GeneratedFile, service parser.Service) {
	// Use service comment as MCP server name if available, otherwise use service name
	serverName := service.Comment
	if serverName == "" {
		serverName = service.Name
	}

	g.P("// NewMCPServerWithTools creates and returns a configured ", service.Name, " MCP server")
	g.P("func New", service.Name, "MCPServer(baseURL string, opts ...connectgomcp.ClientOption) *mcp.Server {")
	g.P("  server := mcp.NewServer(&mcp.Implementation{")
	g.P("    Name: \"", escapeString(serverName), "\",")
	g.P("    Version: \"1.0.0\",")
	g.P("  }, nil)")
	g.P()
	g.P("  toolHandler := connectgomcp.NewToolHandler(baseURL, opts...)")

	// Tool registration for each method
	for i, method := range service.Methods {
		toolName := method.Comment
		if toolName == "" {
			toolName = method.Name
		}

		description := method.RequestComment
		if description == "" {
			description = "Call " + method.Name + " method"
		}

		g.P("  mcp.AddTool(")
		g.P("    server,")
		g.P("    &mcp.Tool{")
		g.P("      Name: \"", escapeString(toolName), "\",")
		g.P("      Description: \"", escapeString(description), "\",")
		g.P("    },")
		g.P("    func(ctx context.Context, req *mcp.CallToolRequest, input map[string]interface{}) (*mcp.CallToolResult, interface{}, error) {")
		g.P("      result, err := toolHandler.Handle(ctx, req, \"", method.Name, "\")")
		g.P("      if err != nil {")
		g.P("        return nil, nil, err")
		g.P("      }")
		g.P("      return result, nil, nil")
		g.P("    },")
		g.P("  )")

		// Add blank line between methods, but not after the last one
		if i < len(service.Methods)-1 {
			g.P()
		}
	}

	g.P()
	g.P("  return server")
	g.P("}")
}

// getParamType gets MCP parameter type
// Note: The new SDK uses a different approach for parameters
func getParamType(goType string) string {
	switch goType {
	case "string":
		return "String"
	case "bool":
		return "Bool"
	case "int32", "int64", "float32", "float64":
		return "Number"
	default:
		return "Object"
	}
}

// escapeString escapes strings for Go string literals
func escapeString(s string) string {
	// Order matters: backslash must be escaped first
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", `\n`)
	s = strings.ReplaceAll(s, "\r", `\r`)
	s = strings.ReplaceAll(s, "\t", `\t`)
	return s
}
