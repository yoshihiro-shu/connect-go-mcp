package template

import (
	"strings"

	"github.com/yoshihiro-shu/connect-go-mcp/cmd/protoc-gen-connect-go-mcp/parser"
	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateCode generates MCP server code
func GenerateCode(g *protogen.GeneratedFile, pkgName string, services []parser.Service) error {
	// Import
	g.P("// Code generated by connect-go-mcp DO NOT EDIT.")
	g.P("package ", pkgName)
	g.P()

	// Import declarations
	generateImports(g, services)
	g.P()

	// Code generation for each service
	for _, service := range services {
		// NewMCPServerWithTools function
		generateServerWithTools(g, service)
		g.P()
	}

	return nil
}

// generateImports generates import declarations
func generateImports(g *protogen.GeneratedFile, services []parser.Service) {
	g.P("import (")
	g.P(`	"context"`)
	g.P()
	g.P(`	"github.com/mark3labs/mcp-go/mcp"`)
	g.P(`	"github.com/mark3labs/mcp-go/server"`)
	g.P(`	connectgomcp "github.com/yoshihiro-shu/connect-go-mcp"`)
	g.P(")")
}

// generateServerWithTools generates MCP server initialization function
func generateServerWithTools(g *protogen.GeneratedFile, service parser.Service) {
	g.P("// NewMCPServerWithTools creates and returns a configured ", service.Name, " MCP server")
	g.P("func New", service.Name, "MCPServer(baseURL string, opts ...connectgomcp.ClientOption) *server.MCPServer {")
	g.P("  server := server.NewMCPServer(\"", service.Name, "\", \"1.0.0\")")
	g.P()
	g.P("  toolHandler := connectgomcp.NewToolHandler(baseURL, opts...)")

	// Tool registration for each method
	for _, method := range service.Methods {
		toolName := method.Comment
		if toolName == "" {
			toolName = method.Name
		}

		g.P("  server.AddTool(")
		g.P(`    mcp.NewTool("`, toolName, `",`)

		// Description
		if method.RequestComment != "" {
			g.P(`      mcp.WithDescription("`, escapeString(method.RequestComment), `"),`)
		}

		// Parameter definitions
		for _, field := range method.RequestFields {
			paramType := getParamType(field.Type)

			g.P(`      mcp.With`, paramType, `("`, field.Name, `",`)
			if field.IsRequired {
				g.P(`        mcp.Required(),`)
			}
			if field.Description != "" {
				g.P(`        mcp.Description("`, escapeString(field.Description), `"),`)
			}
			g.P(`      ),`)
		}

		g.P("    ),")
		g.P("    func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {")
		g.P("      return toolHandler.Handle(ctx, req, \"", method.Name, "\")")
		g.P("    },")
		g.P("  )")
		g.P()
	}

	g.P("  return server")
	g.P("}")
}

// getParamType gets MCP parameter type
func getParamType(goType string) string {
	switch goType {
	case "string":
		return "String"
	case "bool":
		return "Bool"
	case "int32", "int64", "float32", "float64":
		return "Number"
	default:
		return "Object"
	}
}

// escapeString escapes strings
func escapeString(s string) string {
	return strings.ReplaceAll(s, `"`, `\"`)
}
